# Unsafe

- [Unsafe](#unsafe)


Unsafe
- 3 special functions: `unsafe.Sizeof`, `unsafe.Alignof`, `unsafe.Offsetof`
- 1 special types: `unsafe.Pointer`
simple example

example: `unsafe.Sizeof`, `unsafe.Alignof`, `unsafe.Offsetof`

```go
package main

import (
	"fmt"
	"reflect"
	"unsafe"
)

// 16 bytes
type Sample1 struct {
	BoolValue  bool
	IntValue   int32
	FloatValue float64
}

// 24 bytes
type Sample2 struct {
	BoolValue  bool
	FloatValue float64
	IntValue   int32
}

// 16 bytes
type Sample3 struct {
	IntValue   int32
	BoolValue  bool
	FloatValue float64
}

// 24 bytes
type Sample4 struct {
	IntValue   int32
	FloatValue float64
	BoolValue  bool
}

// 16 bytes
type Sample5 struct {
	FloatValue float64
	BoolValue  bool
	IntValue   int32
}

// 16 bytes
type Sample6 struct {
	FloatValue float64
	IntValue   int32
	BoolValue  bool
}

func printLayout(s interface{}) {
	fmt.Println("---------------------")
	sv := reflect.ValueOf(s)
	for i := 0; i < sv.NumField(); i++ {
		field := sv.Type().Field(i)
		fmt.Printf("%s offset: %d bytes\n", field.Name, field.Offset)
	}
}

func main() {
	var s1 Sample1
	var s2 Sample2
	var s3 Sample3
	var s4 Sample4
	var s5 Sample5
	var s6 Sample6
	printLayout(s1)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s1))
	printLayout(s2)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s2))
	printLayout(s3)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s3))
	printLayout(s4)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s4))
	printLayout(s5)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s5))
	printLayout(s6)
	fmt.Printf("total size: %d bytes\n", unsafe.Sizeof(s6))

}
```

example: `unsafe.Pointer` for accelerating r/w bytes
> Just as we used `reflect` to translate text data between the outside world and Go code, we use `unsafe` to translate binary data.

```go
package main

import (
	"encoding/binary"
	"fmt"
	"math/bits"
	"unsafe"
)

var isLE bool

func init() {
	var x uint16 = 0xFF00
	xb := *(*[2]byte)(unsafe.Pointer(&x))
	isLE = (xb[0] == 0x00)
}

func DataFromBytesUnsafe(b [16]byte) Data {
	data := *(*Data)(unsafe.Pointer(&b))
	if isLE {
		data.Value = bits.ReverseBytes32(data.Value)
	}
	return data
}

func DataFromBytes(b [16]byte) Data {
	d := Data{}
	d.Value = binary.BigEndian.Uint32(b[:4])
	copy(d.Label[:], b[4:14])
	d.Active = b[14] != 0
	return d
}

func BytesFromDataUnsafe(d Data) [16]byte {
	if isLE {
		d.Value = bits.ReverseBytes32(d.Value)
	}
	b := *(*[16]byte)(unsafe.Pointer(&d))
	return b
}

func BytesFromData(d Data) [16]byte {
	out := [16]byte{}
	binary.BigEndian.PutUint32(out[:4], d.Value)
	copy(out[4:14], d.Label[:])
	if d.Active {
		out[14] = 1
	}
	return out
}

type Data struct {
	Value  uint32   // 4 bytes
	Label  [10]byte // 10 bytes
	Active bool     // 1 byte
	// padded with 1 byte to make it align
}

func main() {
	// bytes to Data
	b := [16]byte{0, 132, 95, 237, 80, 104, 111, 110, 101, 0, 0, 0, 0, 0, 1, 0}
	fmt.Println("input bytes:", b)
	d1 := DataFromBytes(b)
	d2 := DataFromBytesUnsafe(b)
	if d1 != d2 {
		panic(fmt.Sprintf("%v %v", d1, d2))
	}
	fmt.Println("data from bytes:", d1)

	// Data to bytes
	d := Data{
		Value:  8675309,
		Active: true,
	}
	copy(d.Label[:], "Phone")
	fmt.Println(d, unsafe.Alignof(d), unsafe.Alignof(d.Value), unsafe.Alignof(d.Label), unsafe.Alignof(d.Active))

	b1 := BytesFromData(d)
	b2 := BytesFromDataUnsafe(d)
	if b1 != b2 {
		panic(fmt.Sprintf("%v %v", b1, b2))
	}
	fmt.Printf("bytes from data: %+v\n", b1)
}
```