# Basic

- [Basic](#basic)
	- [array \& slice](#array--slice)
	- [function](#function)
		- [Function Types Are a Bridge to Interfaces](#function-types-are-a-bridge-to-interfaces)
	- [method sets](#method-sets)

## array & slice

what is slice?

```go
// in 64bit architecture, slice size is 24 bytes
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

```go
func main() {
	arr := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	sl := arr[3:7:9]                                   // [4, 5, 6, 7]
	fmt.Println(sl, len(sl), cap(sl))                  // [4 5 6 7] 4 6
	fmt.Printf("slice size: %d\n", unsafe.Sizeof(sl))  // slice size: 24 = 8*3
	fmt.Printf("array size: %d\n", unsafe.Sizeof(arr)) // array size: 80 = 8*10
}
```

## function

### Function Types Are a Bridge to Interfaces

*function type* just likes other *basic types*(int, float64, bool, ...)
> 函数类型为`func(int, float64)`的变量(`greeting`)显示转换为`HandlerFunc`类型，并赋予其新的方法`Do`

```go
type Handler interface {
	Do(int, float64)
}

// HandlerFunc is a function type which meets the Handler interface
type HandlerFunc func(int, float64)

// function type has a method: Do
func (f HandlerFunc) Do(x int, y float64) {
	f(x, y)
}

// function to use
func Serve(x int, y float64, handler Handler) {
	handler.Do(x, y)
}

func greeting(x int, y float64) {
	fmt.Printf("greeting %d and %f\n", x, y)
}

func main() {
	// Serve(1, 2.0, greeting) // greeting not meet the Handler interface
	func1 := HandlerFunc(greeting) // explicitly convert to HandlerFunc
	func1.Do(10, 20.1) // greeting 10 and 20.100000
	Serve(1, 2.0, HandlerFunc(greeting)) // greeting 1 and 2.000000
}
```

## method sets

```go
func dumpMethodSet(i interface{}) {
	dynTyp := reflect.TypeOf(i)

	if dynTyp == nil {
		fmt.Printf("there is no dynamic type\n")
		return
	}

	n := dynTyp.NumMethod()
	if n == 0 {
		fmt.Printf("%s's method set is empty!\n", dynTyp)
		return
	}

	fmt.Printf("%s's method set:\n", dynTyp)
	for j := 0; j < n; j++ {
		fmt.Println("-", dynTyp.Method(j).Name)
	}
	fmt.Printf("\n")
}

type CustomInterface interface {
	M1()
	M2()
	M3()
	M4()
}

type T struct{}

// T not implement CustomInterface
func (T) M1() {}
func (T) M2() {}

// *T implement CustomInterface
func (*T) M3() {}
func (*T) M4() {}

// interesting
type S1 T  // new type

type S2 = T // just alias

type S3 struct{ T } // embedded

func main() {
	var i1 interface{}
	dumpMethodSet(i1)
	dumpMethodSet(&i1)

	var n int
	dumpMethodSet(n)
	dumpMethodSet(&n)

	var t1 T
	dumpMethodSet(t1)
	dumpMethodSet(&t1)
	
	var s1 S1
	dumpMethodSet(s1)
	dumpMethodSet(&s1)

	var s2 S2
	dumpMethodSet(s2)
	dumpMethodSet(&s2)

	var s3 S3
	dumpMethodSet(s3)
	dumpMethodSet(&s3)

	var i2 CustomInterface
	var t2 T
	var pt2 *T
	i2 = pt2 // ok
	i2 = t2  // error, T does not implement CustomInterface
}
```

```bash
# output
there is no dynamic type
*interface {}'s method set is empty!

int's method set is empty!
*int's method set is empty!

main.T's method set:
- M1
- M2

*main.T's method set:
- M1
- M2
- M3
- M4

main.S's method set is empty!
*main.S's method set is empty!

main.T's method set:
- M1
- M2

*main.T's method set:
- M1
- M2
- M3
- M4

main.S's method set:
- M1
- M2

*main.S's method set:
- M1
- M2
- M3
- M4
```