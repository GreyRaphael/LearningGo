# Generics

- [Generics](#generics)
	- [type constraints](#type-constraints)

example: simple generics

```go
package main

import "fmt"

// comparable, any are constraints
func MapKeys[K comparable, V any](m map[K]V) []K {
	result := make([]K, 0, len(m))
	for key := range m {
		result = append(result, key)
	}
	return result
}

func MapValues[K comparable, V any](m map[K]V) []V {
	result := make([]V, 0, len(m))
	for _, value := range m {
		result = append(result, value)
	}
	return result
}

func main() {
	var m = map[int]string{1: "one", 2: "two", 4: "four"}
	keys := MapKeys(m)
	values := MapValues(m)
	fmt.Println(keys)   // [1 2 4]
	fmt.Println(values) // [one two four]
}
```

simple list

```go
package main

import "fmt"

type List[T any] struct {
	head, tail *element[T]
}

type element[T any] struct {
	next *element[T]
	val  T
}

func (lst *List[T]) Push(v T) {
	if lst.tail == nil {
		lst.head = &element[T]{val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &element[T]{val: v}
		lst.tail = lst.tail.next
	}
}

func (lst *List[T]) GetAll() []T {
	var elems []T
	for e := lst.head; e != nil; e = e.next {
		elems = append(elems, e.val)
	}
	return elems
}

func main() {
	lst := List[int]{}
	lst.Push(10)
	lst.Push(13)
	lst.Push(23)
	fmt.Println("list:", lst.GetAll()) // [10 13 23]
}
```

simple stack

```go
package main

import (
	"fmt"
)

//// any, comparable is contraint
// type Stack[T any] struct {
type Stack[T comparable] struct {
	vals []T
}

func (s *Stack[T]) Push(val T) {
	s.vals = append(s.vals, val)
}

func (s *Stack[T]) Pop() (T, bool) {
	if len(s.vals) == 0 {
		var zero T
		return zero, false
	}
	top := s.vals[len(s.vals)-1]
	s.vals = s.vals[:len(s.vals)-1]
	return top, true
}

func (s Stack[T]) Contains(val T) bool {
	for _, v := range s.vals {
		if v == val {
			return true
		}
	}
	return false
}

func main() {
	var s Stack[int]
	s.Push(10)
	s.Push(20)
	s.Push(30)
	fmt.Println(s.Contains(10)) // true
	fmt.Println(s.Contains(5))  // false

	v, ok := s.Pop()
	fmt.Println(v, ok) // 30 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 20 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 10 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 0 false
	// s.Push("nope")
}
```

binary tree

```go
package main

import (
	"fmt"
	"strings"
)

type Orderable[T any] interface {
	// Order returns a value < 0 when the Orderable is less than the supplied value,
	// a value > 0 when the Orderable is greater than the supplied value,
	// and 0 when the two values are equal.
	Order(T) int
}

type Tree[T Orderable[T]] struct {
	val         T
	left, right *Tree[T]
}

func (t *Tree[T]) Insert(val T) *Tree[T] {
	if t == nil {
		return &Tree[T]{val: val}
	}

	switch comp := val.Order(t.val); {
	case comp < 0:
		t.left = t.left.Insert(val)
	case comp > 0:
		t.right = t.right.Insert(val)
	}
	return t
}

func (t *Tree[T]) Contains(val T) bool {
	if t == nil {
		return false
	}
	switch comp := val.Order(t.val); {
	case comp < 0:
		return t.left.Contains(val)
	case comp > 0:
		return t.right.Contains(val)
	default:
		return true
	}
}

type OrderableInt int

func (oi OrderableInt) Order(val OrderableInt) int {
	return int(oi - val)
}

type OrderableString string

func (os OrderableString) Order(val OrderableString) int {
	return strings.Compare(string(os), string(val))
}

func main() {
	var it *Tree[OrderableInt]
	it = it.Insert(5)
	it = it.Insert(3)
	it = it.Insert(10)
	it = it.Insert(2)
	fmt.Println(it.Contains(2))
	fmt.Println(it.Contains(12))
	a := 10
	// uncomment to see a compile-time error
	// it = it.Insert(a)
	it = it.Insert(OrderableInt(a))
	// uncomment to see a compile-time error
	// it = it.Insert(OrderableString("nope"))
}
```

## type constraints

```go
package main

import (
	"fmt"
)

type Numeric interface {
	string | int | int8 | int16 | int32 | int64 | float32 | float64 | uint | uint8 | uint16 | uint32 | uint64 | uintptr
}

type Tree[T Numeric] struct {
	val         T
	left, right *Tree[T]
}

func (t *Tree[T]) Insert(val T) *Tree[T] {
	if t == nil {
		return &Tree[T]{val: val}
	}

	switch {
	case val < t.val:
		t.left = t.left.Insert(val)
	case val > t.val:
		t.right = t.right.Insert(val)
	}
	return t
}

func (t *Tree[T]) Contains(val T) bool {
	if t == nil {
		return false
	}
	switch {
	case val < t.val:
		return t.left.Contains(val)
	case val > t.val:
		return t.right.Contains(val)
	default:
		return true
	}
}

func main() {
	var it *Tree[int]
	it = it.Insert(5)
	it = it.Insert(3)
	it = it.Insert(10)
	it = it.Insert(2)
	fmt.Println(it.Contains(2))
	fmt.Println(it.Contains(12))
	a := 10
	it = it.Insert(a)
	// uncomment to see a compile-time error
	// it = it.Insert("nope")
}
```