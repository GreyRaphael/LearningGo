# Generics

- [Generics](#generics)
	- [type constraints](#type-constraints)
	- [type approximation](#type-approximation)
	- [use `constraints` package](#use-constraints-package)
	- [Generic Functions Abstract Algorithms](#generic-functions-abstract-algorithms)

example: simple generics

```go
package main

import "fmt"

// comparable, any are constraints
func MapKeys[K comparable, V any](m map[K]V) []K {
	result := make([]K, 0, len(m))
	for key := range m {
		result = append(result, key)
	}
	return result
}

func MapValues[K comparable, V any](m map[K]V) []V {
	result := make([]V, 0, len(m))
	for _, value := range m {
		result = append(result, value)
	}
	return result
}

func main() {
	var m = map[int]string{1: "one", 2: "two", 4: "four"}
	keys := MapKeys(m)
	values := MapValues(m)
	fmt.Println(keys)   // [1 2 4]
	fmt.Println(values) // [one two four]
}
```

simple list

```go
package main

import "fmt"

type List[T any] struct {
	head, tail *element[T]
}

type element[T any] struct {
	next *element[T]
	val  T
}

func (lst *List[T]) Push(v T) {
	if lst.tail == nil {
		lst.head = &element[T]{val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &element[T]{val: v}
		lst.tail = lst.tail.next
	}
}

func (lst *List[T]) GetAll() []T {
	var elems []T
	for e := lst.head; e != nil; e = e.next {
		elems = append(elems, e.val)
	}
	return elems
}

func main() {
	lst := List[int]{}
	lst.Push(10)
	lst.Push(13)
	lst.Push(23)
	fmt.Println("list:", lst.GetAll()) // [10 13 23]
}
```

simple stack

```go
package main

import (
	"fmt"
)

//// any, comparable is contraint
// type Stack[T any] struct {
type Stack[T comparable] struct {
	vals []T
}

func (s *Stack[T]) Push(val T) {
	s.vals = append(s.vals, val)
}

func (s *Stack[T]) Pop() (T, bool) {
	if len(s.vals) == 0 {
		var zero T
		return zero, false
	}
	top := s.vals[len(s.vals)-1]
	s.vals = s.vals[:len(s.vals)-1]
	return top, true
}

func (s Stack[T]) Contains(val T) bool {
	for _, v := range s.vals {
		if v == val {
			return true
		}
	}
	return false
}

func main() {
	var s Stack[int]
	s.Push(10)
	s.Push(20)
	s.Push(30)
	fmt.Println(s.Contains(10)) // true
	fmt.Println(s.Contains(5))  // false

	v, ok := s.Pop()
	fmt.Println(v, ok) // 30 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 20 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 10 true
	v, ok = s.Pop()
	fmt.Println(v, ok) // 0 false
	// s.Push("nope")
}
```

binary tree

```go
package main

import (
	"fmt"
	"strings"
)

type Orderable[T any] interface {
	// Order returns a value < 0 when the Orderable is less than the supplied value,
	// a value > 0 when the Orderable is greater than the supplied value,
	// and 0 when the two values are equal.
	Order(T) int
}

type Tree[T Orderable[T]] struct {
	val         T
	left, right *Tree[T]
}

func (t *Tree[T]) Insert(val T) *Tree[T] {
	if t == nil {
		return &Tree[T]{val: val}
	}

	switch comp := val.Order(t.val); {
	case comp < 0:
		t.left = t.left.Insert(val)
	case comp > 0:
		t.right = t.right.Insert(val)
	}
	return t
}

func (t *Tree[T]) Contains(val T) bool {
	if t == nil {
		return false
	}
	switch comp := val.Order(t.val); {
	case comp < 0:
		return t.left.Contains(val)
	case comp > 0:
		return t.right.Contains(val)
	default:
		return true
	}
}

type OrderableInt int

func (oi OrderableInt) Order(val OrderableInt) int {
	return int(oi - val)
}

type OrderableString string

func (os OrderableString) Order(val OrderableString) int {
	return strings.Compare(string(os), string(val))
}

func main() {
	var it *Tree[OrderableInt]
	it = it.Insert(5)
	it = it.Insert(3)
	it = it.Insert(10)
	it = it.Insert(2)
	fmt.Println(it.Contains(2))
	fmt.Println(it.Contains(12))
	a := 10
	// uncomment to see a compile-time error
	// it = it.Insert(a)
	it = it.Insert(OrderableInt(a))
	// uncomment to see a compile-time error
	// it = it.Insert(OrderableString("nope"))
}
```

## type constraints

simple constraints: `[T int | int64]`

```go
func Sum[T int | int64](args ...T) T {
	var sum T
	for i := 0; i < len(args); i++ {
		sum += args[i]
	}
	return sum
}

func main() {
	fmt.Println(Sum(1, 2, 3, 4, 5))
	fmt.Println(Sum([]int{1, 2, 3}...))
	fmt.Println(Sum([]int64{10, 20, 30}...))
}
```

```go
package main

import (
	"fmt"
)

type Numeric interface {
	string | int | int8 | int16 | int32 | int64 | float32 | float64 | uint | uint8 | uint16 | uint32 | uint64 | uintptr
}

type Tree[T Numeric] struct {
	val         T
	left, right *Tree[T]
}

func (t *Tree[T]) Insert(val T) *Tree[T] {
	if t == nil {
		return &Tree[T]{val: val}
	}

	switch {
	case val < t.val:
		t.left = t.left.Insert(val)
	case val > t.val:
		t.right = t.right.Insert(val)
	}
	return t
}

func (t *Tree[T]) Contains(val T) bool {
	if t == nil {
		return false
	}
	switch {
	case val < t.val:
		return t.left.Contains(val)
	case val > t.val:
		return t.right.Contains(val)
	default:
		return true
	}
}

func main() {
	var it *Tree[int]
	it = it.Insert(5)
	it = it.Insert(3)
	it = it.Insert(10)
	it = it.Insert(2)
	fmt.Println(it.Contains(2))
	fmt.Println(it.Contains(12))
	a := 10
	it = it.Insert(a)
	// uncomment to see a compile-time error
	// it = it.Insert("nope")
}
```

## type approximation

> [tutorial](https://blog.logrocket.com/understanding-generics-go-1-18/)

```go
package main

import "fmt"

// Any Type with given underlying type will be supported by this interface
type Number interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 | ~float32 | ~float64
}

// Type with underlying int
type Point int

func Min[T Number](x, y T) T {
	if x < y {
		return x
	}
	return y
}

func main() {
	// creating Point type
	x, y := Point(5), Point(2)
	fmt.Println(Min(x, y))
}
```

```go
package main

import "fmt"

// Integer is made up of all the int types
type Integer interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
}

// Float is made up of all the float type
type Float interface {
	~float32 | ~float64
}

// Number is build from Integer and Float
type Number interface {
	Integer | Float
}

// Using Number
func Min[T Number](x, y T) T {
	if x < y {
		return x
	}
	return y
}

// Type with underlying int
type Point int

func main() {
	// creating Point type
	x, y := Point(5), Point(2)
	fmt.Println(Min(x, y))
}
```

## use `constraints` package

```go
// You can edit this code!
// Click here and start typing.
package main

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

func min[T constraints.Ordered](x, y T) T {
	if x > y {
		return x
	} else {
		return y
	}
}

func main() {
	fmt.Println(min('a', 'b'))
}
```

## Generic Functions Abstract Algorithms

```go
package main

import (
	"fmt"
)

// Map turns a []T1 to a []T2 using a mapping function.
// This function has two type parameters, T1 and T2.
// This works with slices of any type.
func Map[T1, T2 any](s []T1, f func(T1) T2) []T2 {
	r := make([]T2, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

// Reduce reduces a []T1 to a single value using a reduction function.
func Reduce[T1, T2 any](s []T1, initializer T2, f func(T2, T1) T2) T2 {
	r := initializer
	for _, v := range s {
		r = f(r, v)
	}
	return r
}

// Filter filters values from a slice using a filter function.
// It returns a new slice with only the elements of s
// for which f returned true.
func Filter[T any](s []T, f func(T) bool) []T {
	var r []T
	for _, v := range s {
		if f(v) {
			r = append(r, v)
		}
	}
	return r
}

func main() {
	words := []string{"One", "Potato", "Two", "Potato"}
	filtered := Filter(words, func(s string) bool {
		return s != "Potato"
	})
	fmt.Println(filtered) // [One Two]

	lengths := Map(filtered, func(s string) int {
		return len(s)
	})
	fmt.Println(lengths) // [3 3]

	sum := Reduce(lengths, 0, func(acc int, val int) int {
		return acc + val
	})
	fmt.Println(sum) // 6
}
```

```go
package main

import (
	"fmt"
	"reflect"
)

type Integer interface {
	int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64
}

func Convert[T1, T2 Integer](in T1) T2 {
	return T2(in)
}
func main() {
	var a int = 10
	b := Convert[int, int64](a)
	fmt.Println(reflect.TypeOf(b), b) // int64 10
}
```