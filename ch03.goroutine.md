# Goroutine & Channel

- [Goroutine \& Channel](#goroutine--channel)
	- [How channels behave](#how-channels-behave)
	- [dead lock](#dead-lock)
	- [timers \& ticks](#timers--ticks)
	- [goroutine pool](#goroutine-pool)
	- [rate limiter](#rate-limiter)
	- [custom stateful goroutine](#custom-stateful-goroutine)

## How channels behave

|  | Unbuffered,open | Unbuffered,closed | Buffered,open | Buffered,closed | nil |
|---|---|---|---|---|---|
| Read | Pause until something is written | Return zero value (use comma ok to see if closed) | Pause if buffer is empty | Return a remaining value in the buffer. If the buffer is empty, return zero value (use comma ok to see if closed) | hang forever |
| Write | Pause until something is read | panic | Pause if buffer is full | panic | hang forever |
| Close | works | panic | Works, remaining values still there | panic | panic |

> launch goroutines with a closure that wraps business logic

```go
package main

import (
	"fmt"
	"time"
)

func businessLogic(val int) int {
	return val * 10
}

func main() {
	inputChan := make(chan int)
	outputChan := make(chan int)

	go func() {
		fmt.Println("goroutine1 begin")
		for val := range inputChan {
			fmt.Println("goroutine1 receive:", val)
			result := businessLogic(val)

			fmt.Println("goroutine1 send:", result)
			outputChan <- result
		}
		close(outputChan)
	}()

	go func() {
		fmt.Println("goroutine2 begin")
		for i := 1; i <= 3; i++ {
			time.Sleep(time.Second * 3)
			fmt.Println("goroutine2 send:", i)
			inputChan <- i
		}
		close(inputChan)
	}()

	// receive data in main goroutine
	for result := range outputChan {
		fmt.Println("main goroutine receive:", result)
	}
}
```

recommended goroutines

```go
package main

import (
	"fmt"
	"time"
)

func businessLogic(val int) int {
	return val * 10
}

func process(in <-chan int, out chan<- int) {
	go func() {
		fmt.Println("goroutine1 begin")
		for val := range in {
			fmt.Println("goroutine1 receive:", val)
			result := businessLogic(val)

			fmt.Println("goroutine1 send:", result)
			out <- result
		}
		close(out)
	}()
}

func prepare(out chan<- int) {
	go func() {
		fmt.Println("goroutine2 begin")
		for i := 1; i <= 3; i++ {
			time.Sleep(time.Second * 3)
			fmt.Println("goroutine2 send:", i)
			out <- i
		}
		close(out)
	}()
}

func show(in <-chan int) {
	for val := range in {
		fmt.Println("main goroutine receive:", val)
	}
}

func main() {
	inputChan := make(chan int)
	outputChan := make(chan int)

	process(inputChan, outputChan)
	prepare(inputChan)
	show(outputChan)
}
```

## dead lock

simple block
- *closure goroutine*, write 1 to `ch1`, Pause until `ch1` is read
- *main goroutine*, write 2 to `ch2`, Pause until `ch2` is read

```go
package main

import (
	"fmt"
)

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		fmt.Println("closure goroutine start")
		ch1 <- 1 // block here
		v2 := <-ch2
		fmt.Println("closure:", v2)
	}()

	fmt.Println("main goutine here")
	ch2 <- 2 // block here
	v2 := <-ch1
	fmt.Println("main:", v2)
}
```

another dead lock

```go
package main

import (
	"fmt"
)

func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		fmt.Println("closure goroutine start")
		ch1 <- 1 // block here
		v2 := <-ch2
		fmt.Println("closure, value =:", v2)
	}()

	fmt.Println("main goutine here")
	for {
		select {
		case ch2 <- 2:
			fmt.Println("case1")
		case v2 := <-ch1:
			fmt.Println("case2, value =", v2)
		}
	}
}
```

```bash
main goutine here
closure goroutine start
case2, value = 1
case1
closure, value =: 2
fatal error: all goroutines are asleep - deadlock!
```

example: simple goroutines

```go
package main

import (
	"fmt"
	"time"
)

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
		time.Sleep(time.Second)
	}
}

func main() {

	f("direct")

	go f("goroutine")

	go func(msg string) {
		fmt.Println(msg)
	}("going")

	time.Sleep(time.Second)
	fmt.Println("done")
}
// direct : 0
// direct : 1
// direct : 2
// going
// goroutine : 0
// goroutine : 1
// done
```

example: simple channel

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	messages := make(chan string)

	go func() {
		time.Sleep(time.Second * 3)
		fmt.Println("in goroutine func")
		messages <- "ping"
	}()

	fmt.Println("---")
	msg := <-messages
	fmt.Println("xxx", msg)
}
// ---
// in goroutine func
// xxx ping
```

example: channel buffering

```go
package main

import "fmt"

func main() {

	messages := make(chan string, 2)

	messages <- "buffered"
	messages <- "channel"

	fmt.Println(<-messages)
	fmt.Println(<-messages)
	// fmt.Println(<-messages) // error, only 2 messages in the buffer
}
```

example: channel synchronization

```go
package main

import (
	"fmt"
	"time"
)

func worker(done chan bool) {
	fmt.Println("working...")
	time.Sleep(time.Second)
	fmt.Println("work done")

	done <- true
}

func main() {

	done := make(chan bool, 1)
	go worker(done)

	fmt.Println("waiting for flag")
	<-done // waiting for flag
	fmt.Println("ending for flag")
}
// waiting for flag
// working...
// work done
// ending for flag
```

example: channel direction

```go
package main

import "fmt"

func ping(pings chan<- string, msg string) {
	pings <- msg
}

func pong(pings <-chan string, pongs chan<- string) {
	// receive then send
	msg := <-pings
	pongs <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}
```

example: channel `select`

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		time.Sleep(1 * time.Second)
		c1 <- "one"
	}()
	go func() {
		// time.Sleep(1 * time.Second)
		time.Sleep(2 * time.Second)
		c2 <- "two"
	}()

	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-c1:
			fmt.Println("received", msg1)
		case msg2 := <-c2:
			fmt.Println("received", msg2)
		}
	}
}
// received one
// received two
```

example: channel `timeout`

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	c1 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}
// timeout 1
// result 2
```

example: non-blocking channel receive
> Basic sends and receives on channels are blocking. `select` + `default`, implement non-blocking sends, receives, and even non-blocking multi-way selects.

- case1: Here’s a non-blocking **receive**. If a value is available on `messages` then `select` will take the `<-messages` case with that value. If not it will immediately take the `default` case.
- case2: A non-blocking **send** works similarly. Here `msg` cannot be sent to the `messages` channel, because the channel has *no buffer* and there is *no receiver*. Therefore the `default` case is selected.
- case3: We can use multiple `cases` above the `default` clause to implement a multi-way non-blocking select. Here we attempt non-blocking receives on both `messages` and `signals`.

```go
package main

import "fmt"

func main() {
    messages := make(chan string)
    signals := make(chan bool)

    // case1
    select {
    case msg := <-messages:
        fmt.Println("received message", msg)
    default:
        fmt.Println("no message received")
    }

    // case2
    msg := "hi"
    select {
    case messages <- msg:
        fmt.Println("sent message", msg)
    default:
        fmt.Println("no message sent")
    }

    // case3
    select {
    case msg := <-messages:
        fmt.Println("received message", msg)
    case sig := <-signals:
        fmt.Println("received signal", sig)
    default:
        fmt.Println("no activity")
    }
}
// no message received
// no message sent
// no activity
```

modification

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	messages := make(chan string, 10) // change here
	signals := make(chan bool)

	go func() {
		messages <- "one"
	}()
	time.Sleep(time.Second) // change here

	// case1
	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	default:
		fmt.Println("no message received")
	}

	// case2
	msg := "hi"
	select {
	case messages <- msg:
		fmt.Println("sent message", msg)
	default:
		fmt.Println("no message sent")
	}

	// case3
	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	case sig := <-signals:
		fmt.Println("received signal", sig)
	default:
		fmt.Println("no activity")
	}
}
// received message one
// sent message hi
// received message hi
```

example: close channels

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	go func() {
		for {
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()

	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
		time.Sleep(time.Second * 2)
	}
	close(jobs)
	fmt.Println("sent all jobs")

	<-done

	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
// sent job 1
// received job 1
// sent job 2
// received job 2
// sent job 3
// received job 3
// sent all jobs
// received all jobs
// received more jobs: false
```

example: range over channel

```go
package main

import "fmt"

func main() {

	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue) // channel must be closed

	for elem := range queue {
		fmt.Println(elem)
	}
}
```

## timers & ticks

example: timers

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	timer1 := time.NewTimer(2 * time.Second)

	<-timer1.C
	fmt.Println("Timer 1 fired")

	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	time.Sleep(2 * time.Second)
}
// Timer 1 fired
// Timer 2 stopped
```

example: ticker

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	ticker := time.NewTicker(500 * time.Millisecond)
	done := make(chan bool)

	go func() {
		for {
			select {
			case <-done:
				fmt.Println("bye bye")
				return
			case t := <-ticker.C:
				fmt.Println("Tick at", t)
			}
		}
	}()

	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	done <- true
	time.Sleep(time.Second)
	fmt.Println("Ticker stopped")
}
// Tick at 2024-01-10 01:33:06.1817271 +0800 CST m=+0.514428101
// Tick at 2024-01-10 01:33:06.6794341 +0800 CST m=+1.012135101
// Tick at 2024-01-10 01:33:07.1855028 +0800 CST m=+1.518203801
// bye bye
// Ticker stopped
```

## goroutine pool

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Println("worker", id, "started  job", j)
		num := rand.Intn(5)
		time.Sleep(time.Duration(num) * time.Second)
		fmt.Println("worker", id, "finished job", j, "costs", num)
		results <- j * 2
	}
}

func main() {
	const numJobs = 5
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	fmt.Println("---")
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	fmt.Println("xxx")
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	fmt.Println("+++")
	for a := 1; a <= numJobs; a++ {
		<-results
	}
	fmt.Println("***")
}
// ---
// xxx
// +++
// worker 3 started  job 1
// worker 1 started  job 2
// worker 2 started  job 3
// worker 1 finished job 2 costs 2
// worker 1 started  job 4
// worker 2 finished job 3 costs 3
// worker 2 started  job 5
// worker 3 finished job 1 costs 4
// worker 1 finished job 4 costs 2
// worker 2 finished job 5 costs 3
// ***
```

To wait for multiple goroutines to finish

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int) {
	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		wg.Add(1)

		// Interesting, Avoid re-use of the same i value in each goroutine closure.
		i := i

		go func() {
			worker(i)
			wg.Done()
		}()
	}
	wg.Wait()
}
// Worker 5 starting
// Worker 2 starting
// Worker 4 starting
// Worker 1 starting
// Worker 3 starting
// Worker 3 done
// Worker 1 done
// Worker 4 done
// Worker 2 done
// Worker 5 done
```

use `defer` 推迟wg.Done()到`}`最后

```go
func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		wg.Add(1)

		i := i

		go func() {
			// Interesting
			defer wg.Done()
			worker(i)
		}()
	}
	wg.Wait()
}
```

*atomic counters* for goroutines communication

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var ops atomic.Uint64

	var wg sync.WaitGroup

	// 64 goroutines count from 0 to 1280000000
	for i := 0; i < 64; i++ {
		wg.Add(1)

		go func() {
			for c := 0; c < 20000000; c++ {
				ops.Add(1)
			}

			wg.Done() // wg减少1
		}()
	}

	wg.Wait() // 等待wg变成0

	fmt.Println("ops:", ops.Load()) // 1280000000
}
```

simple counter state can use `atomic`, `Mutex` is for more complex case

```go
package main

import (
	"fmt"
	"sync"
)

type Container struct {
	mu       sync.Mutex
	counters map[string]int
}

func (c *Container) inc(name string) {

	c.mu.Lock()
	defer c.mu.Unlock()
	c.counters[name]++
}

func main() {
	c := Container{

		counters: map[string]int{"a": 0, "b": 0},
	}

	var wg sync.WaitGroup

	// normal closure
	doIncrement := func(name string, n int) {
		for i := 0; i < n; i++ {
			c.inc(name)
		}
		wg.Done()
	}

	wg.Add(3)
	go doIncrement("a", 10000)
	go doIncrement("a", 10000)
	go doIncrement("b", 10000)

	wg.Wait()
	fmt.Println(c.counters)
}
```

## rate limiter

example: simple rate limiting, `1 request/s`

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	requests := make(chan int, 5)
	for i := 1; i <= 5; i++ {
		requests <- i
	}
	close(requests)

	simpleLimiter := time.Tick(1000 * time.Millisecond)

	for req := range requests {
		<-simpleLimiter
		fmt.Println("request", req, time.Now())
	}
}
```

example: allow short bursts of requests in our rate limiting scheme while preserving the overall rate limit. 
> first 3 requests: burst; last 7 requests `1 request/s`

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	burstyLimiter := make(chan time.Time, 3)

	// this is the key part, allow first 3 request to burst
	for i := 0; i < 3; i++ {
		burstyLimiter <- time.Now()
	}

	go func() {
		for t := range time.Tick(1000 * time.Millisecond) {
			burstyLimiter <- t
		}
	}()

	burstyRequests := make(chan int, 10)
	for i := 1; i <= 10; i++ {
		burstyRequests <- i
	}
	close(burstyRequests)

	for req := range burstyRequests {
		<-burstyLimiter
		fmt.Println("request", req, time.Now())
	}
}
```

## custom stateful goroutine

```go
package main

import (
	"fmt"
	"math/rand"
	"sync/atomic"
	"time"
)

type readOp struct {
	key  int
	resp chan int
}
type writeOp struct {
	key  int
	val  int
	resp chan bool
}

func main() {
	var readOps uint64
	var writeOps uint64

	reads := make(chan readOp)
	writes := make(chan writeOp)

	go func() {
		var state = make(map[int]int)
		for {
			select {
			case read := <-reads:
				read.resp <- state[read.key]
			case write := <-writes:
				state[write.key] = write.val
				write.resp <- true
			}
		}
	}()

	for r := 0; r < 100; r++ {
		go func() {
			for {
				read := readOp{
					key:  rand.Intn(5),
					resp: make(chan int)}
				reads <- read
				// here is interesting
				<-read.resp
				atomic.AddUint64(&readOps, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}

	for w := 0; w < 10; w++ {
		go func() {
			for {
				write := writeOp{
					key:  rand.Intn(5),
					val:  rand.Intn(100),
					resp: make(chan bool)}
				writes <- write
				// here is interesting
				<-write.resp
				atomic.AddUint64(&writeOps, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}

	time.Sleep(time.Second)

	readOpsFinal := atomic.LoadUint64(&readOps)
	fmt.Println("readOps:", readOpsFinal)
	writeOpsFinal := atomic.LoadUint64(&writeOps)
	fmt.Println("writeOps:", writeOpsFinal)
}
```