# Goroutine & Channel

- [Goroutine \& Channel](#goroutine--channel)
  - [timers \& ticks](#timers--ticks)

example: simple goroutines

```go
package main

import (
	"fmt"
	"time"
)

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
		time.Sleep(time.Second)
	}
}

func main() {

	f("direct")

	go f("goroutine")

	go func(msg string) {
		fmt.Println(msg)
	}("going")

	time.Sleep(time.Second)
	fmt.Println("done")
}
// direct : 0
// direct : 1
// direct : 2
// going
// goroutine : 0
// goroutine : 1
// done
```

example: simple channel

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	messages := make(chan string)

	go func() {
		time.Sleep(time.Second * 3)
		fmt.Println("in goroutine func")
		messages <- "ping"
	}()

	fmt.Println("---")
	msg := <-messages
	fmt.Println("xxx", msg)
}
// ---
// in goroutine func
// xxx ping
```

example: channel buffering

```go
package main

import "fmt"

func main() {

	messages := make(chan string, 2)

	messages <- "buffered"
	messages <- "channel"

	fmt.Println(<-messages)
	fmt.Println(<-messages)
	// fmt.Println(<-messages) // error, only 2 messages in the buffer
}
```

example: channel synchronization

```go
package main

import (
	"fmt"
	"time"
)

func worker(done chan bool) {
	fmt.Println("working...")
	time.Sleep(time.Second)
	fmt.Println("work done")

	done <- true
}

func main() {

	done := make(chan bool, 1)
	go worker(done)

	fmt.Println("waiting for flag")
	<-done // waiting for flag
	fmt.Println("ending for flag")
}
// waiting for flag
// working...
// work done
// ending for flag
```

example: channel direction

```go
package main

import "fmt"

func ping(pings chan<- string, msg string) {
	pings <- msg
}

func pong(pings <-chan string, pongs chan<- string) {
	// receive then send
	msg := <-pings
	pongs <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}
```

example: channel `select`

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		time.Sleep(1 * time.Second)
		c1 <- "one"
	}()
	go func() {
		// time.Sleep(1 * time.Second)
		time.Sleep(2 * time.Second)
		c2 <- "two"
	}()

	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-c1:
			fmt.Println("received", msg1)
		case msg2 := <-c2:
			fmt.Println("received", msg2)
		}
	}
}
// received one
// received two
```

example: channel `timeout`

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	c1 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}
// timeout 1
// result 2
```

example: non-blocking channel receive
> Basic sends and receives on channels are blocking. `select` + `default`, implement non-blocking sends, receives, and even non-blocking multi-way selects.

- case1: Hereâ€™s a non-blocking **receive**. If a value is available on `messages` then `select` will take the `<-messages` case with that value. If not it will immediately take the `default` case.
- case2: A non-blocking **send** works similarly. Here `msg` cannot be sent to the `messages` channel, because the channel has *no buffer* and there is *no receiver*. Therefore the `default` case is selected.
- case3: We can use multiple `cases` above the `default` clause to implement a multi-way non-blocking select. Here we attempt non-blocking receives on both `messages` and `signals`.

```go
package main

import "fmt"

func main() {
    messages := make(chan string)
    signals := make(chan bool)

    // case1
    select {
    case msg := <-messages:
        fmt.Println("received message", msg)
    default:
        fmt.Println("no message received")
    }

    // case2
    msg := "hi"
    select {
    case messages <- msg:
        fmt.Println("sent message", msg)
    default:
        fmt.Println("no message sent")
    }

    // case3
    select {
    case msg := <-messages:
        fmt.Println("received message", msg)
    case sig := <-signals:
        fmt.Println("received signal", sig)
    default:
        fmt.Println("no activity")
    }
}
// no message received
// no message sent
// no activity
```

modification

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	messages := make(chan string, 10)
	signals := make(chan bool)

	go func() {
		messages <- "one"
	}()
	time.Sleep(time.Second)

	// case1
	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	default:
		fmt.Println("no message received")
	}

	// case2
	msg := "hi"
	select {
	case messages <- msg:
		fmt.Println("sent message", msg)
	default:
		fmt.Println("no message sent")
	}

	// case3
	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	case sig := <-signals:
		fmt.Println("received signal", sig)
	default:
		fmt.Println("no activity")
	}
}
// received message one
// sent message hi
// received message hi
```

example: close channels

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	go func() {
		for {
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()

	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
		time.Sleep(time.Second * 2)
	}
	close(jobs)
	fmt.Println("sent all jobs")

	<-done

	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
// sent job 1
// received job 1
// sent job 2
// received job 2
// sent job 3
// received job 3
// sent all jobs
// received all jobs
// received more jobs: false
```

example: range over channel

```go
package main

import "fmt"

func main() {

	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue) // channel must be closed

	for elem := range queue {
		fmt.Println(elem)
	}
}
```

## timers & ticks

example: timers

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	timer1 := time.NewTimer(2 * time.Second)

	<-timer1.C
	fmt.Println("Timer 1 fired")

	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	time.Sleep(2 * time.Second)
}
// Timer 1 fired
// Timer 2 stopped
```

example: ticker

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	ticker := time.NewTicker(500 * time.Millisecond)
	done := make(chan bool)

	go func() {
		for {
			select {
			case <-done:
				fmt.Println("bye bye")
				return
			case t := <-ticker.C:
				fmt.Println("Tick at", t)
			}
		}
	}()

	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	done <- true
	time.Sleep(time.Second)
	fmt.Println("Ticker stopped")
}
// Tick at 2024-01-10 01:33:06.1817271 +0800 CST m=+0.514428101
// Tick at 2024-01-10 01:33:06.6794341 +0800 CST m=+1.012135101
// Tick at 2024-01-10 01:33:07.1855028 +0800 CST m=+1.518203801
// bye bye
// Ticker stopped
```